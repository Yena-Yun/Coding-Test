### 문제 설명

숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.

예를 들어, t="3141592"이고 p="271" 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다. 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.

### 제한사항

1 ≤ p의 길이 ≤ 18
p의 길이 ≤ t의 길이 ≤ 10,000
t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.

### 풀이 과정

자릿 수만큼 계속 옮기는 과정을 보자니 예전에 공부했던 '슬라이딩 윈도우'가 떠올랐다.
i와 j를 찍은 다음 (창문을 옆으로 밀듯이) 하나씩 옆으로 옮기는 걸 그대로 for문으로 구현했더니 해결되었음

1. t 문자열을 순회할 때 p의 자릿수만큼 거리를 가진 인덱스 두 게를 점 찍음

- i와 j가 각각 어디부터 어디까지 돌 것인지 시작점과 끝점을 설정
- i는 0부터 t의 맨 끝에서 p의 길이만큼 뺀 곳까지 (콘솔 값이 잘 안나와서 1을 더해줌)
- j는 p의 길이 - 1 지점에서 t의 길이 바로 앞까지 돌도록 설정

2. t를 p만큼 자른 것을 picked 변수로 선언
3. picked의 길이가 p의 길이와 동일할 때
4. picked를 숫자화(parseInt)한 값이 p를 숫자화한 값보다 작거나 같으면 answer에 +1

=> 결과: 테스트 케이스와 정확도 케이스 모두 통과했다

### 다른 풀이

도중에 slice로 t를 자르는 부분에서 p.length와 i를 활용할 수 있어서 <br/>
이중 for문은 돌지 않아도 되었다 (근데 복잡도 케이스 모두 통과..?) <br/>
그리고 이렇게 명확한 길이로 자르기 때문에<br/>
picked의 길이와 p의 길이도 다시 확인할 필요 없다<br/>
(기존 풀이에서도 이 부분을 발견했지만 이 부분을 지운 경우 답이 안 뜸)<br/>
~어쩐지.. 전부 다 통과했는데 점수가 그렇게 안 높더라~

=> 최대한 원래 있는 것, 기존 것을 활용해 연산할 수 있는지 생각해보기
