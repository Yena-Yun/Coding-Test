[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/155652)

### 문제 설명

두 문자열 s와 skip, 그리고 자연수 index가 주어질 때, 다음 규칙에 따라 문자열을 만들려 합니다. 암호의 규칙은 다음과 같습니다.

문자열 s의 각 알파벳을 index만큼 뒤의 알파벳으로 바꿔줍니다.
index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아갑니다.
skip에 있는 알파벳은 제외하고 건너뜁니다.
예를 들어 s = "aukks", skip = "wbqd", index = 5일 때, a에서 5만큼 뒤에 있는 알파벳은 f지만 [b, c, d, e, f]에서 'b'와 'd'는 skip에 포함되므로 세지 않습니다. 따라서 'b', 'd'를 제외하고 'a'에서 5만큼 뒤에 있는 알파벳은 [c, e, f, g, h] 순서에 의해 'h'가 됩니다. 나머지 "ukks" 또한 위 규칙대로 바꾸면 "appy"가 되며 결과는 "happy"가 됩니다.

두 문자열 s와 skip, 그리고 자연수 index가 매개변수로 주어질 때 위 규칙대로 s를 변환한 결과를 return하도록 solution 함수를 완성해주세요.

### 풀이 과정

원래 풀이

1. 전체 알파벳 배열 선언 (상수이므로 함수 바깥에 선언)
2. 알파벳 상수에서의 s가 시작하는 인덱스로 alphabetIndex 시작
3. alphabets을 alphabetIndex번째부터 시작해서 순환
   - 도중에 alphabets[alphabetIndex]가 'z'가 되면 alphabetIndex를 0('a')으로 초기화
4. alphabets이 skip 배열에 없으면 alphabetIndex에 1 추가, 있으면 0 추가
5. alphabetIndex가 index와 동일해지면 리턴
6. alphabets의 alphabetIndex번째 문자를 answer에 추가

=> 문제점: 출력되는 answer가 hkpy에서 더 이상 바뀌지 않았다.
'index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아간다'와 관련된 예외 처리가 안 됐다.

[ 문제 풀이 시 참고 사항]

- 핵심: Set 자료구조를 사용해서 skip되는 알파벳을 모두 제거한 후 시작
- 마지막 알파벳 z일 때 다시 첫 알파벳 a로 돌아가는 순회 구조는 나눈 나머지(%)를 구해서 가능
- Set을 쓰면 요소를 삭제하기 쉬워지고, 중복을 없앨 수 있다.

새 풀이

1. 전체 알파벳 문자열을 Set 자료 구조로 생성

   - new Set() 객체 안에 Set으로 바꿀 문자열을 추가
   - 또는 new Set().add('')로 추가 가능
   - 그 외 기능: has(원소를 갖고 있는지 여부), .size(length 구하기, 메서드 아님)

2. skip 문자열을 배열로 바꾼 뒤 순회하며 알파벳 Set에서 skip 문자 제거

- \*\* spread를 사용하면 문자열이나 Set을 배열로 만들 수 있다.

3. index가 더해진 최종 인덱스 구하기: s 문자열에서 하나씩 꺼낸 문자를 배열로 바꾼 알파벳 Set에서 인덱스를 찾고
   index를 더해서 최종 인덱스(= index만큼 뒤의 알파벳의 위치)를 구함

4. index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아오기: 구한 최종 인덱스를 알파벳 배열의 전체 길이로 나눈 '나머지'를 구함

5. 알파벳 전체 배열에서 '나머지' 인덱스를 찾아 answer 문자열에 추가

[ 나머지 연산자를 순환에 활용하는 원리 ]

- skip을 제외한 총 22개 알파벳 중 index를 더한 최종 인덱스가 22(마지막 알파벳)가 되었을 경우,
  전체 알파벳 갯수인 22로 나누면 나머지가 0, 즉 맨 처음 원소('a')를 가리키게 된다.
