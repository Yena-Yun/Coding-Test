### 문제 설명

아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

명함 번호 가로 길이 세로 길이
1 60 50
2 30 70
3 60 30
4 80 40

가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

### 제한 사항

sizes의 길이는 1 이상 10,000 이하입니다.
sizes의 원소는 [w, h] 형식입니다. // 문제 풀이 중 형태에 대한 힌트!

### 풀이 과정

원래 풀이
이번 문제는 '제일 큰 세로가 제일 큰 가로보다 작을 경우 두 번째로 작은 세로를 선택한다.
이때 만약 선택한 세로에 해당하는 가로의 길이가 세로 중 두 번째로 큰 것보다 높다면
그 가로를 세로로 선택한다'라는 규칙은 찾았지만 구현에 실패해서 원 코드 없음 ^\_^

새 풀이
요약: '명함을 눕힌다' = '가로와 세로가 서로 바뀐다'
최대 명함 지갑 너비를 얻으려면 가로 길이 중 최대, 세로 길이 중 최대를 서로 곱해야 한다.
그리고 가로와 세로를 제대로 비교하기 위해 세로가 가로보다 더 긴 명함의 경우 가로, 세로의 위치를 서로 바꿔준다.

1. 배열 destructuring을 활용하여 2차원 배열을 map으로 돌면서 [w, h] 형태로 꺼내기
2. w와 h를 비교하여 h가 더 큰 경우 자리 교체해서 반환
3. maxSize 변수 선언 (초기값: [0, 0])
4. 새 배열을 forEach로 돌면서 maxSize와 비교하여 각각 최대 가로와 최대 세로를 구해서 곱함
