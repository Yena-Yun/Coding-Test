[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/155652)

### 문제 설명

두 문자열 s와 skip, 그리고 자연수 index가 주어질 때, 다음 규칙에 따라 문자열을 만들려 합니다. 암호의 규칙은 다음과 같습니다.

문자열 s의 각 알파벳을 index만큼 뒤의 알파벳으로 바꿔줍니다.
index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아갑니다.
skip에 있는 알파벳은 제외하고 건너뜁니다.
예를 들어 s = "aukks", skip = "wbqd", index = 5일 때, a에서 5만큼 뒤에 있는 알파벳은 f지만 [b, c, d, e, f]에서 'b'와 'd'는 skip에 포함되므로 세지 않습니다. 따라서 'b', 'd'를 제외하고 'a'에서 5만큼 뒤에 있는 알파벳은 [c, e, f, g, h] 순서에 의해 'h'가 됩니다. 나머지 "ukks" 또한 위 규칙대로 바꾸면 "appy"가 되며 결과는 "happy"가 됩니다.

두 문자열 s와 skip, 그리고 자연수 index가 매개변수로 주어질 때 위 규칙대로 s를 변환한 결과를 return하도록 solution 함수를 완성해주세요.

### 제한사항

5 ≤ s의 길이 ≤ 50
1 ≤ skip의 길이 ≤ 10
s와 skip은 알파벳 소문자로만 이루어져 있습니다.
skip에 포함되는 알파벳은 s에 포함되지 않습니다.
1 ≤ index ≤ 20

### 풀이 과정

- [ 원래 풀이 ]

1. 전체 알파벳 배열 선언 (상수이므로 함수 바깥에 선언)
2. 알파벳 상수에서의 s가 시작하는 인덱스로 alphabetIndex 시작
3. alphabets을 alphabetIndex번째부터 시작해서 순환
   - 도중에 alphabets[alphabetIndex]가 'z'가 되면 alphabetIndex를 0('a')으로 초기화
4. alphabets이 skip 배열에 없으면 alphabetIndex에 1 추가, 있으면 0 추가
5. alphabetIndex가 index와 동일해지면 리턴
6. alphabets의 alphabetIndex번째 문자를 answer에 추가

- 문제점: 출력되는 answer가 hkpy에서 더 이상 바뀌지 않았다. <br/>
  'index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아간다'는 예외 처리가 안 됨

- [ 새 풀이 ]
  핵심: Set 자료구조를 사용해서 skip되는 알파벳을 모두 제거한 후 시작, <br/>
  z일 때 다시 a로 돌아가는 순회 구조는 나머지 연산자(%)를 활용 <br/>
  (Set 쓰면 삭제 메서드 쓰기 쉬워지고, 중복이 없어지며, 원소의 총 갯수를 숫자로 알려줘서 편함)

1. 알파벳 원소 전체를 Set으로 생성

- new Set() 한 뒤에 .add 메서드로 원소를 추가해도 되고, new Set에 인자를 바로 넣어서 생성할 수도 있음
- Set의 그 외 기능: has(원소를 갖고 있는지 여부), .size(메서드 아님, length)

2. skip 문자열을 spread로 배열화
3. forEach로 순환하며 알파벳에서 skip 요소 제거
4. 이후 알파벳 Set을 spread를 통해 배열로 만듦

- \*\* spread를 사용하면 문자열이나 Set을 배열로 만들 수 있다.

5. for-of로 문자열(string)을 돌면서 현재 string의 인덱스를 indexOf로 가져온다.
6. 주어진 index를 더해서 실제로 받아올 알파벳의 인덱스(idx)를 찾음
7. 알파벳 인덱스(idx)를 알파벳 전체 배열의 길이로 나눈 나머지 값을 구해 <br/>
   마지막 요소가 되었을 때 바로 첫 번째로 돌아와 다시 돌게 한다. <br/>
   예: 17번째인 'u'에서 index 5를 더하면 22번째, 즉 'a'가 되어야 함 <br/>
   5를 더한 값인 22에서 전체 배열 길이 22를 나누면 나머지가 0, 즉 배열의 첫 번째 문자인 'a'를 가져옴
8. 구한 알파벳 문자를 answer에 추가한다.

- 나머지 연산자의 원리:
- 총 22개 알파벳 중, index를 더한 최종 idx가 22(마지막 순서)가 되면,
- 전체 알파벳 갯수 22로 나누면 나머지 0, 즉 맨 처음 원소를 가리키게 된다.
- 마지막에 도달했을 때 처음으로 돌아가 다시 순환해야 하는 경우 나머지 연산자 활용하기
